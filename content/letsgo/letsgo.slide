# Let's Go!
An Introduction to the Go Programming Environment
18 Jun 2024

Arnaud Lasnier

## A new business line for Back Market

## Setup, Tooling & Demo

## Application Startup

## Basics

Variables:

```go
var i int         // declaration
i = 10            // assignment
var j int = 10    // declaration and assignment
k := 10           // short notation
```

Main function, main package and hello world!

.play -edit hello_world.go

## Structs, Tags & Methods

A **struct** is a collection of fields. Fields can have **tags**. Structs can have **methods**.

.play -numbers structs.go

## Pointers

Go is a **pass-by-value language** and has **pointers**:

.play -numbers increment.go /START OMIT/,/END OMIT/

You cannot dereference a `nil` pointer without a **runtime error**:

.play -numbers nil_deref.go

<!-- Unlike C, there is no pointer arithmetic in Go. -->

<!-- .play -numbers pointers.go -->

## Create Player Modal and HTMX Overview

## Schema Migrations and Models Generation

## Starting a Tournament: Error Handling

## Interfaces

The `error` interface is defined like this:

```go
type error interface {
	Error() string
}
```

## Error Handling in Practice

## Generating Matches

## Zero Values

Variables declared without an explicit initial value are given their **zero value**.

<!-- The zero value is:

- `0` for numeric types,
- `false` for the boolean type,
- `""` (the empty string) for strings. -->

.play -numbers zero_values.go

## Nil

The zero value of the following Go types is **`nil`**.

```go
var p *int              // nil (pointer)
var s []int             // nil (slice)
var m map[string]int    // nil (map)
var c chan int          // nil (channel)
var f func()            // nil (function)
var i interface{}       // nil (interface)
```

`nil` is not a value on its own: it must have a type. So the following does **not** even compile:

.play nil_equals_nil.go

## Slices

Nil slices:

.play nil_slice.go  /START OMIT/,/END OMIT/

Nil slice indexing:

.play nil_slice_indexing.go  /START OMIT/,/END OMIT/

Allocations with `make`:

.play slice_allocation.go  /START OMIT/,/END OMIT/

Slice length:

.play slice_length.go  /START OMIT/,/END OMIT/

## Slices: append, len and cap

.play append.go

## Using Pointers for Optionality

For a long time, Go did not have optionals. So people used pointers instead.

.play -numbers opt_unsafe.go

## Using True Optionals (Go 1.18+)

.play -numbers opt_safe.go

## Where to go from here?

1.  Install go on your machine:
	[go.dev/dl](https://go.dev/dl)
2.  Get familiar with the language:
	[go.dev/tour](https://go.dev/tour)
3.  Get familiar with the `go` CLI:
	[pkg.go.dev/cmd/go](https://pkg.go.dev/cmd/go)
4.  Get familiar with the standard library:
	[pkg.go.dev/std](https://pkg.go.dev/std)
5.  Build and run this code:
	[github.com/ArnaudLasnier/pingpong](https://github.com/ArnaudLasnier/pingpong)
